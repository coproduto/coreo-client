module VoteList exposing (Model, Msg, update, view, init)
{-| Module to generate a list of votes,
consisting of each votable option together
with the number of votes associated with it.

@docs Model

@docs Msg

@docs update

@docs view 

@docs init
-}

import Html as H exposing (Html)
import Html.Attributes as Attr
import Html.Events as Events

{-| Underlying data for a VoteList, containing a simple list of (String, Int) type
-}
type alias Model = 
  { votes : List (String, Int) 
  , votedForOption : Maybe String
  }

{-| Type for messages generated from a voteList.
A message generated by the list always contains a
string identifying which option was voted for. 
-}
type Msg
  = VoteForOption String

{-| Initialize the voteList. It takes a list of strings representing
the possible voting options as a parameter. 
-}
init : List String -> (Model, Cmd Msg)
init options = 
  (Model (List.map (\x -> (x,0)) options) Nothing , Cmd.none)

{-| Step the vote list whenever we get a new vote 
-}
update : Msg -> Model -> (Model, Cmd Msg)
update message model =
  case message of
    VoteForOption str ->
      case model.votedForOption of
        Just voted ->
          if voted == str then
            ({ model | votes = dispatchAction decrement str model.votes 
                     , votedForOption = Nothing
             }
            , Cmd.none
            )
          else
            (model, Cmd.none)

        Nothing ->
          ({ model | votes = dispatchAction increment str model.votes 
           , votedForOption = Just str 
           }
          , Cmd.none
          )

{-| The voteList gets shown as an HTML `ul` element with
the name of the option, the number of votes, and a voting
button. -} 
view : Model -> Html Msg
view model = 
  H.div []
     [ voteList model.votes ]
      
--helper functions
voteList : List (String, Int) -> Html Msg
voteList pairList =
  let list =
    List.map listElem pairList
  in H.ul [] list

listElem : (String, Int) -> Html Msg
listElem (str, n) =
  H.li []
     [ H.text (str ++ ":" ++ (toString n))
     , H.button
         [ Events.onClick (VoteForOption str) ]
         [ H.text "Vote" ] 
     ]

dispatchAction : (a -> a) -> b -> List (b, a) -> List (b, a)
dispatchAction action target list =
  case list of
    ((a, b) :: rest) ->
      if a == target then (a, (action b)) :: rest
      else (a,b) :: (dispatchAction action target rest)

    [] -> []

increment x = x + 1

decrement x = x - 1
--

